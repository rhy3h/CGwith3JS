<!DOCTYPE html>

<html>

<head>
	<style>
		body {
			background-color: #fff;
			color: #111;
			margin: 0px;
			overflow: hidden;
			font-family: Monospace;
			font-size: 20px;
			position: absolute;
		}

		#info {
			position: absolute;
			top: 5%;
			width: 100%;
			padding: 5px;
			text-align: center;
			color: #ffff00
		}

		#loading {
			z-index: 10;
			position: absolute;
			width: 100%;
			height: 100%;
			text-align: center;
			margin: 0 auto;
			color: #ffffff;
			font-size: 40px;
		}
	</style>
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	<link rel="icon" href="../files/images/favicon.ico" type="image/x-icon" />
	<title>Hw6</title>
</head>

<body>
	<div id="loading" class="align-middle">loading...</div>
	<div id="info">hw6</div>
	
	<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/build/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/examples/js/loaders/MTLLoader.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/examples/js/loaders/OBJLoader.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/examples/js/geometries/TeapotBufferGeometry.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.117.0/examples/js/utils/BufferGeometryUtils.js"></script>

	<script id="myVertexShader" type="x-shader/x-vertex">
	varying vec2 vUv;
	void main() {
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		vUv = uv;
	}
</script>
	<script id="myFragmentShader" type="x-shader/x-fragment">
	varying vec2 vUv;
	uniform sampler2D fronttex;
	uniform sampler2D backtex;
	void main() {
		vec3 color;
		if (gl_FrontFacing){
		color = texture2D(fronttex, vUv).rgb;
	} else {
		vec2 backUv = vec2 (1.0-vUv.s, vUv.t);
		color = texture2D(backtex, backUv).rgb;
	}
	gl_FragColor = vec4(color, 1.0); }
</script>

	<script id="myVertexShader-mono" type="x-shader/x-vertex">
	varying vec2 vUv; 
	void main() { 
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
		vUv = uv; 
	}
</script>
	<script id="myFragmentShader-mono" type="x-shader/x-fragment">
	uniform sampler2D texture; 
	varying vec2 vUv; 
	
	vec3 rgb2hsv(vec3 c) {
		vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
		vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
		vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

		float d = q.x - min(q.w, q.y);
		float e = 1.0e-10;
		return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	}
	vec3 hsv2rgb(vec3 c) {
		vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
		vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
		return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
	}
  
	void main() { 
		vec3 color = texture2D (texture, vUv).rgb;
		vec3 hh = rgb2hsv (color);
		hh.y = 0.0;  // set saturation to 0
		vec3 cc = hsv2rgb (hh);
		gl_FragColor = vec4 (cc, 1.0); 
	}
</script>

	<script id="myToonVertexShader" type="x-shader/x-vertex">
	uniform vec3 lightpos;
	
	varying vec3 lightdir;
	varying vec3 eyenorm;
	
	void main() {
		gl_Position = projectionMatrix* modelViewMatrix * vec4(position, 1.0);
		
		vec4 eyepos = modelViewMatrix * vec4 (position, 1.0);
		vec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);
		lightdir = lighteye.xyz - eyepos.xyz;
		eyenorm = normalMatrix * normal;
	}
</script>
	<script id="myToonFragmentShader" type="x-shader/x-fragment">
	uniform float opacity;
	
	varying vec3 lightdir;
	varying vec3 eyenorm;
	
	void main() {
		float nn = dot (normalize(lightdir), normalize(eyenorm));
		if (nn > 0.8) {
			nn= 1.0;
		} else if (nn > 0.6) {
			nn = 0.6;
		} else {
			nn = 0.2;
		}
		vec3 color = vec3 (0./255., 255./255., 255./255.);
		color = color * nn;
		gl_FragColor = vec4 (color, opacity);
	}
</script>

	<script id="vsCut" type="x-shader/x-vertex">
 	 varying vec2 vUv; 
 	 void main() { 
    	gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
    	vUv = uv; 
  	}
</script>
	<script id="fsCut" type="x-shader/x-vertex">
	uniform sampler2D texture; 
  	varying vec2 vUv;
  	void main() {
  		vec3 color = texture2D (texture, vUv).rgb;
  		if (color.r > 0.95 && color.g > 0.95 && color.b < 0.05)  // close to (1,1,0)
  	   		discard;
  		else
  			gl_FragColor = vec4 (color, 1);
  	}
</script>

	<!-- shader for eyeNormal Plot -->
	<script id="vsNormal" type="x-shader/x-vertex">
	varying vec3 vNormal;
	void main() { 
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
		vNormal = normalMatrix*normal;
	}
</script>
	<script id="fsNormal" type="x-shader/x-fragment">
	varying vec3 vNormal; // [-1,1]^3
	void main() {    
		vec3 color = (normalize(vNormal)+1.0)/2.; // [0,1]^3
		gl_FragColor = vec4 (color,1);
	}
</script>

	<script id="vsFilter" type="x-shader/x-vertex">
	varying vec2 vUv; 
	void main() { 
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
		vUv = uv; 
	}
</script>
	<script id="fsFilter" type="x-shader/x-fragment">
	uniform sampler2D texture; 
	int imageSize;
	vec2 vUv; 
	void main() { 
		float step_w = 1.0/float(imageSize); 
		float step_h = 1.0/float(imageSize); 
		// Laplace filter
		float kernel[9]; 
		kernel[0] = kernel[2] = kernel[6] = kernel[8] = 0.0/1.0; 
		kernel[1] = kernel[3] = kernel[5] = kernel[7] = 1.0/1.0; 
		kernel[4] = -4.0/1.0; 
		vec2 offset[9]; 
		offset[0]=vec2(-step_w, -step_h); 
		offset[1]=vec2(0.0, -step_h); offset[2]= vec2(step_w, -step_h), 
		offset[3]=vec2(-step_w, 0.0), offset[4]=vec2(0.0, 0.0), offset[5]=vec2(step_w, 0.0), 
		offset[6]=vec2(-step_w, step_h), offset[7]=vec2(0.0, step_h), offset[8]=vec2(step_w, step_h); 
  
		vec3 sum= vec3(0.0); 
		for (int i=0 ; i < 9; i++) { 
			vec3 tmp=texture2D (texture, vUv+offset[i]).rgb; 
			sum += tmp*kernel[i]; 
		}

    	if ((sum.r+sum.g+sum.b)/3.0 < 0.1) // if close to (0,0,0)
  	   		discard;
    	else 
  	   		gl_FragColor = vec4 (0,0,0, 1.0); 
}
</script>

	<script id="vs-texSwap" type="x-shader/x-vertex">
	uniform int which; // 0, 1, 2, 3
	varying vec2 vUv; 
	void main() {
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);      
		vUv = vec2 ((uv.s + float(which))/4., uv.t); 
	}
</script>
	<script id="fs-texSwap" type="x-shader/x-fragment">
    uniform sampler2D texture; 
    varying vec2 vUv; 
	void main() {
		vec3 color = texture2D (texture, vUv).rgb;
		gl_FragColor = vec4 (color, 1.0); 
	}
</script>

	<script id="vs-sobel" type="x-shader/x-vertex">
	varying vec2 vUv; 
	void main() { 
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
		vUv = uv; 
	}
</script>
	<script id="fs-sobel" type="x-shader/x-fragment">
  	uniform sampler2D texture; 
	uniform vec2 imageSize;
	varying vec2 vUv; 
	float step_w = 1.0/imageSize.x; 
	float step_h = 1.0/imageSize.y; 
	void main() { 
		float kernel[9];
	
		vec2 offset[9]; 
		offset[0]=vec2(-step_w, -step_h); 
		offset[1]=vec2(0.0, -step_h); offset[2]= vec2(step_w, -step_h), 
		offset[3]=vec2(-step_w, 0.0), offset[4]=vec2(0.0, 0.0), offset[5]=vec2(step_w, 0.0), 
		offset[6]=vec2(-step_w, step_h), offset[7]=vec2(0.0, step_h), offset[8]=vec2(step_w, step_h); 
		
		// sobel filter - Gx
		for (int i = 0; i < 9; i++) kernel[i]=0.0; 
		kernel[0] = -1.0; kernel[2] = 1.0;
		kernel[3] = -2.0; kernel[5] =  2.0;
		kernel[6] = -1.0; kernel[8] = 1.0;
		
		vec3 sumX= vec3(0.0); 
        for (int i=0 ; i < 9; i++) { 
			vec3 tmp=texture2D (texture, vUv+offset[i]).rgb; 
			sumX += tmp*kernel[i]; 
		}
        
		// sobel filter - Gy
		for (int i = 0; i < 9; i++) kernel[i]=0.0; 
		kernel[6] = -1.0; kernel[7] = -2.0; kernel[8] = -1.0;
		kernel[0] = 1.0; kernel[1] = 2.0; kernel[2] = 1.0;
			
		vec3 sumY= vec3(0.0); 
		for (int i=0 ; i < 9; i++) { 
			vec3 tmp=texture2D (texture, vUv+offset[i]).rgb; 
			sumY += tmp*kernel[i]; 
		}
		vec3 delX = vec3 (1, 0, sumX);
		vec3 delY = vec3 (0, 1, sumY);
		vec3 n = normalize (cross (delX, delY));
		
		vec3 encode = (n + vec3 (1))/2.0;
		
		gl_FragColor = vec4 (encode, 1.0); 
}
</script>

	<script id="vs-normalmap" type="x-shader/x-vertex">
	uniform vec3 lightpos;

	attribute vec4 tangent;
	varying vec2 vUv;
	varying vec3 vTangent;
	varying vec3 vBitangent;
	varying vec3 vNormal;
	varying vec3 vLL;

	void main() {
		vec4 vWorldpos = modelMatrix * vec4( position, 1.0 ) ;
		vec2 myrepeat = vec2 (1.0, 1.0);
		vUv = myrepeat*uv;

		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		// TBN in eyespace 
		// no need to normalize these varying variable
		// as they will be normalized in fragment shader
		//
		vNormal = normalMatrix * normal ;
		vTangent = normalMatrix * tangent.xyz ;
		vBitangent = cross( vNormal, vTangent ) ;

		vLL = normalMatrix * (lightpos - vWorldpos.xyz);
	}
</script>
	<script id='fs-normalmap' type="x-shader/x-vertex">
	uniform sampler2D tNormal;
	varying vec2 vUv;
	varying vec3 vTangent;
	varying vec3 vBitangent;
	varying vec3 vNormal;
	varying vec3 vLL;

	void main() {
		vec3 normalTex = texture2D (tNormal, vUv).xyz * 2.0 - 1.0;
		normalTex.xy *= 6.0;    // exaggerate the normal deviation
		normalTex = normalize( normalTex );

		mat3 tsb = mat3( normalize( vTangent ), normalize( vBitangent ), normalize( vNormal ) );
		vec3 finalNormal = tsb * normalTex;
		float ndotl = dot (normalize (vLL), normalize (finalNormal));
		gl_FragColor = vec4( vec3(ndotl), 1 );
	}
</script>

	<script id="vs-mosaic" type="x-shader/x-vertex">
	varying vec2 vUv; 
	void main() { 
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
		vUv = uv; 
	}
</script>
	<script id="fs-mosaic" type="x-shader/x-fragment">
	uniform sampler2D texture; 
	varying vec2 vUv; 
	uniform float gran;
	vec2 vUvm;
	uniform vec2 headNDC;
	
	void main() {
		float d = distance (headNDC, vUv); 
		if(gran != 0.01){
			gl_FragColor = texture2D (texture, vUv);
		}
		else if (d < 0.06) {
			vUvm = floor (vUv/gran)*gran;     
			gl_FragColor = texture2D(texture, vUvm); 
		} else if (d < 0.07 && gran == 0.01) {
			gl_FragColor = vec4(1, 0, 0, 1);
		} else {
			vUvm = vUv;
        	gl_FragColor = texture2D(texture, vUvm); 
		}
	}
</script>
	<script id='perlinVertexShader' type="x-shader/x-vertex">
    varying vec4 wPos;
    varying vec2 vUv;
    uniform vec2 scale;
    uniform vec2 offset;
    
	void main() {
        vUv = uv * scale + offset;
        wPos = modelMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
	<script id='perlinFragmentShader' type="x-shader/x-vertex">
    vec3 mod289(vec3 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 permute(vec4 x) {
        return mod289(((x * 34.0) + 1.0) * x);
    }

    vec4 taylorInvSqrt(vec4 r) {
        return 1.79284291400159 - 0.85373472095314 * r;
    }

    float snoise(vec3 v) {
        const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        // First corner
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        //   x0 = x0 - 0.0 + 0.0 * C.xxx;
        //   x1 = x0 - i1  + 1.0 * C.xxx;
        //   x2 = x0 - i2  + 2.0 * C.xxx;
        //   x3 = x0 - 1.0 + 3.0 * C.xxx;
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
        vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y

        // Permutations
        i = mod289(i);
        vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        // Gradients: 7x7 points over a square, mapped onto an octahedron.
        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
        float n_ = 0.142857142857; // 1.0/7.0
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)

        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        //Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),
        dot(p2, x2), dot(p3, x3)));
    }

    uniform int terms;
    uniform int use2D;
    uniform float time;
	uniform vec3 rgb;
	varying vec2 vUv;
    varying vec4 wPos;
    
    float surface3(vec3 coord) {
        float height = 0.0;
        height += abs(snoise(coord)) * 1.0;
        if (terms >= 2)    
            height += abs(snoise(coord * 2.0)) * 0.5;
        if (terms >= 3)
            height += abs(snoise(coord * 4.0)) * 0.25;
        if (terms >= 4)
            height += abs(snoise(coord * 8.0)) * 0.125;
        // can add more terms ...
        if (terms >= 5)   
             height += abs(snoise(coord * 16.0)) * 0.0625;
        return height;
    }

    void main() {
        float scale = 1.0;
        vec3 coord = vec3(scale * vUv[0], scale * vUv[1], time);
        float height = surface3(coord);

        float r;
        r = height;
		gl_FragColor = vec4(r*rgb[0], r*rgb[1], r*rgb[2], 1.0);
    }
</script>

	<script>
		$("#info").hide();
		var camera, renderer;
		var sceneGrey, scene0, sceneColor;
		var shaderMaterial;
		var sceneTexSwap, cameraTexSwap, which = 0;
		var sceneSobel, cameraSobel, lightPoster, lightAngle = 0;
		var subject, subjectClone;
		var sceneMosaic;
		var objNameList = [], finish = false, angle = 0;

		init();
		animate();

		function init() {
			setRender();
			setCamera();
			buildSceneGrey();
			buildScene1();
			buildSceneRTT();
			buildSceneRegular();
			buildScene0();
			buildSceneColor();
			buildPoster();
			buildPerlin();
		}

		function setRender() {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			renderer.setClearColor(0x888888);
			renderer.autoClear = false;

			window.addEventListener('resize', onWindowResize, false);
		}

		function onWindowResize() {
			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function setCamera() {
			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.y = 180;
			camera.position.z = 125;
			controls = new THREE.OrbitControls(camera, renderer.domElement);
		}

		function readModel(modelName, targetSize = 40) {

			let onProgress = function (xhr) {

				if (xhr.lengthComputable) {
					let percentComplete = xhr.loaded / xhr.total * 100;
					console.log(Math.round(percentComplete, 2) + '% downloaded');
				}

			};

			let onError = function (xhr) { };

			let mtlLoader = new THREE.MTLLoader();
			mtlLoader.setPath('../files/models/');
			mtlLoader.load(modelName + '.mtl', function (materials) {

				materials.preload();

				let objLoader = new THREE.OBJLoader();
				objLoader.setMaterials(materials);
				objLoader.setPath('../files/models/');
				objLoader.load(modelName + '.obj', function (object) {

					let theObject = unitize(object, targetSize);
					theObject.add(new THREE.BoxHelper(theObject))
					theObject.name = modelName;
					sceneColor.add(theObject);
					theObject.setRotationFromEuler(new THREE.Euler(0, 3.1416, 0, 'XYZ'))
					// ??OBJ??
				}, onProgress, onError);

			});

		}

		function unitize(object, targetSize) {

			// find bounding box of 'object'
			let box3 = new THREE.Box3();
			box3.setFromObject(object);
			let size = new THREE.Vector3();
			size.subVectors(box3.max, box3.min);
			let center = new THREE.Vector3();
			center.addVectors(box3.max, box3.min).multiplyScalar(0.5);

			console.log('center: ' + center.x + ', ' + center.y + ', ' + center.z);
			console.log('size: ' + size.x + ', ' + size.y + ', ' + size.z);

			// uniform scaling according to objSize
			let objSize = Math.max(size.x, size.y, size.z);
			let scaleSet = targetSize / objSize;

			let theObject = new THREE.Object3D();
			theObject.add(object);
			object.scale.set(scaleSet, scaleSet, scaleSet);
			object.position.set(-center.x * scaleSet, -center.y * scaleSet + size.y / 2 * scaleSet, -center.z * scaleSet);

			return theObject;

		}

		function buildSceneGrey() {
			let wall = buildWall();
			let desk = buildDesk();
			let light = buildLight();
			let tryit = buildTryit();
			let penbox = buildPenBox();

			sceneGrey = new THREE.Scene();
			sceneGrey.add(wall, desk, tryit, penbox);
			sceneGrey.add(light);
		}

		function buildScene1() {
			var material_shh_normal = new THREE.ShaderMaterial({
				vertexShader: document.getElementById('vsNormal').textContent,
				fragmentShader: document.getElementById('fsNormal').textContent
			});
			scene1 = new THREE.Scene();
			camera1 = new THREE.OrthographicCamera(-20, 20, 20, -20, -200, 200);
			subject = new THREE.Mesh(new THREE.TeapotBufferGeometry(5), material_shh_normal);
			scene1.add(subject);
		}

		function buildSceneRTT() {
			renderTargetTeapot = new THREE.WebGLRenderTarget(512, 512);
			material_shh = new THREE.ShaderMaterial({
				uniforms: {
					imageSize: { type: 'i', value: renderTargetTeapot.width },
					texture: { type: 't', value: renderTargetTeapot.texture }
				},
				vertexShader: document.getElementById('vsFilter').textContent,
				fragmentShader: document.getElementById('fsFilter').textContent
			});
			// sceneRTT: contains a plane to draw the outline  
			sceneRTT = new THREE.Scene();
			cameraRTT = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 10);
			var bs = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), material_shh);
			sceneRTT.add(bs);
			renderTarget_whole = new THREE.WebGLRenderTarget(512, 512);
		}

		function buildSceneRegular() {
			sceneRegular = new THREE.Scene();
			let ToonGeometry = new THREE.TeapotBufferGeometry(5);
			let ToonMaterial = new THREE.ShaderMaterial({
				transparent: true,
				uniforms: {
					lightpos: { type: 'v3', value: new THREE.Vector3(0, 30, 20) },
					shading: { type: 'i', value: 0 },
					opacity: { type: 'f', value: 1.0 },
				},
				vertexShader: document.getElementById('myToonVertexShader').textContent,
				fragmentShader: document.getElementById('myToonFragmentShader').textContent
			});
			subjectClone = subject.clone();
			subjectClone.material = ToonMaterial;
			sceneRegular.add(subjectClone);
		}

		function buildScene0() {
			let width = window.innerWidth;
			let height = window.innerHeight;

			scene0 = new THREE.Scene();
			camera0 = new THREE.OrthographicCamera(0, width, height, 0, -10, 100);
			renderTarget = new THREE.WebGLRenderTarget(width, height);
			shaderMaterial = new THREE.ShaderMaterial({
				uniforms: {
					texture: { type: 't', value: renderTarget.texture },
				},
				vertexShader: document.getElementById('myVertexShader-mono').textContent,
				fragmentShader: document.getElementById('myFragmentShader-mono').textContent,

				depthTest: false,  // no depth test
				depthWrite: false  // do not write depth buffer
			});
			// plane geometry filled the entire screen
			let plane0 = new THREE.Mesh(new THREE.PlaneGeometry(width, height), shaderMaterial);
			scene0.add(plane0);
			plane0.position.set(width / 2, height / 2, 0);

		}

		function buildSceneColor() {
			sceneColor = new THREE.Scene();
			sceneRed = new THREE.Scene();
			cutoutShaderMat = new THREE.ShaderMaterial({
				uniforms: {
					texture: { type: 't', value: renderTarget_whole.texture }
				},
				vertexShader: document.getElementById('vsCut').textContent,
				fragmentShader: document.getElementById('fsCut').textContent
			});

			planeXX = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), cutoutShaderMat);
			planeXX.position.set(-15, 32, -15);
			sceneColor.add(planeXX);
			readModel("Trump");
			objNameList.push("Trump");

			renderTargetColor = new THREE.WebGLRenderTarget(1600, 900);

			var uniforms = {
				headNDC: {
					type: 'v2',
					value: null
				},
				texture: {
					type: 't',
					value: renderTargetColor.texture
				},
				gran: {
					type: 'f',
					value: 0
				}
			};
			var vertShader = document.getElementById('vs-mosaic').innerHTML;
			var fragShader = document.getElementById('fs-mosaic').innerHTML;
			material_Moscaic = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertShader,
				fragmentShader: fragShader
			});

			plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), material_Moscaic);
			cameraRed = new THREE.OrthographicCamera(-50, 50, 50, -50, -100, 100);
			sceneRed.add(plane);
		}

		function buildSwap() {
			texSwapRenderTarget = new THREE.WebGLRenderTarget(120, 240);
			sceneTexSwap = new THREE.Scene();
			cameraTexSwap = new THREE.OrthographicCamera(-60, 60, 120, -120, -10, 100);
			var uniforms = {
				texture: {
					type: 't',
					value: null
				},
				which: {
					type: 'i',
					value: 0
				}
			};
			var vertShader = document.getElementById('vs-texSwap').textContent;
			var fragShader = document.getElementById('fs-texSwap').textContent;
			shaderMaterial = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertShader,
				fragmentShader: fragShader
			});
			let loader = new THREE.TextureLoader();
			loader.crossOrigin = '';
			let myface = 'https://i.imgur.com/RpS3W3J.jpg';
			let texture = loader.load(myface, function (tex) {
				texture.wrapS = THREE.RepeatWrapping;
				console.log(tex.image.width + ', ' + tex.image.height);
				shaderMaterial.uniforms.texture.value = tex;
			});
			let plane = new THREE.Mesh(new THREE.PlaneGeometry(120, 240), shaderMaterial);
			sceneTexSwap.add(plane);
			function incWhich() {
				which += 1;
				shaderMaterial.uniforms.which.value = which;
				setTimeout(incWhich, 500);
			}
			setTimeout(incWhich, 0);
		}

		function buildSobel() {
			sceneSobel = new THREE.Scene();
			cameraSobel = new THREE.OrthographicCamera(-60, 60, 120, -120, -10, 100);
			var uniforms = {
				imageSize: {
					type: 'v2',
					value: new THREE.Vector2(256, 256)
				},
				texture: {
					type: 't',
					value: texSwapRenderTarget.texture
				},
			};
			var vertShader = document.getElementById('vs-sobel').textContent;
			var fragShader = document.getElementById('fs-sobel').textContent;
			material_shader = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertShader,
				fragmentShader: fragShader,
				side: THREE.DoubleSide
			});
			var geometry = new THREE.PlaneGeometry(120, 240);
			var mesh = new THREE.Mesh(geometry, material_shader);
			sceneSobel.add(mesh)
			sobelRenderTarget = new THREE.WebGLRenderTarget(120, 240);
		}

		function buildPoster() {
			buildSwap();
			buildSobel();

			var geometry = new THREE.PlaneBufferGeometry(30, 34);
			THREE.BufferGeometryUtils.computeTangents(geometry);
			var uniforms = {
				imageSize: {
					type: 'v2',
					value: 512
				},
				tNormal: {
					type: 't',
					value: sobelRenderTarget.texture
				},
				lightpos: {
					type: 'v3',
					value: new THREE.Vector3()
				}
			};
			var vertShader = document.getElementById('vs-normalmap').textContent;
			var fragShader = document.getElementById('fs-normalmap').textContent;
			shaderMaterialNormal = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertShader,
				fragmentShader: fragShader
			});
			let mesh2 = new THREE.Mesh(geometry, shaderMaterialNormal);
			sceneColor.add(mesh2);
			mesh2.position.x = 30;
			mesh2.position.y = 30;
			mesh2.position.z = -48;

			lightPoster = new THREE.PointLight();
			sceneColor.add(lightPoster);
			sceneColor.add(new THREE.PointLightHelper(lightPoster, 5));
		}

		function makeShaderMaterial() {

			var material = new THREE.ShaderMaterial({
				side: THREE.DoubleSide,
				uniforms: {
					terms: {
						type: 'i',
						value: 8
					},
					time: {
						type: 'f',
						value: 1.0
					},
					scale: {
						type: 'v2',
						value: new THREE.Vector2(1, 1)
					},
					offset: {
						type: 'v2',
						value: new THREE.Vector2(1, 10)
					},
					rgb: {
						type: 'v3',
						value: new THREE.Vector3(0. / 255., 255. / 255., 64. / 255.)
					}
				},
				vertexShader: document.getElementById('perlinVertexShader').textContent,
				fragmentShader: document.getElementById('perlinFragmentShader').textContent,

			});
			return material;
		}

		function buildPerlin() {
			let perlin = new THREE.Object3D();

			let geometry2 = new THREE.PlaneGeometry(50, 20, 2);
			let loader = new THREE.TextureLoader();
			let texture = loader.load('https://i.imgur.com/x8InJSc.png');
			let material2 = new THREE.MeshPhongMaterial({
				alphaMap: texture,
				transparent: true,
			});
			mesh3 = new THREE.Mesh(geometry2, material2);
			let geometry = new THREE.BoxGeometry(50, 20, 2);
			let material = makeShaderMaterial();
			mesh2 = new THREE.Mesh(geometry, material);
			perlin.add(mesh2, mesh3);
			mesh2.position.z = -1.1;
			sceneColor.add(perlin);
			perlin.position.z = -47;
			perlin.position.y = 60;
		}

		function buildWall() {
			let wall = new THREE.Object3D();
			let material = new THREE.MeshPhongMaterial({ color: "white" });
			let wall1 = new THREE.Mesh(new THREE.BoxGeometry(122, 80, 2), material);
			wall1.position.set(0, 40, -50);
			wall.add(wall1);
			let wall2 = new THREE.Mesh(new THREE.BoxGeometry(102, 80, 2), material);
			wall2.position.set(-60, 40, 0);
			wall2.rotation.y = Math.PI / 2;
			wall.add(wall2);
			let wall3 = new THREE.Mesh(new THREE.BoxGeometry(102, 80, 2), material);
			wall3.position.set(60, 40, 0);
			wall3.rotation.y = Math.PI / 2;
			wall.add(wall3);
			let wall4 = new THREE.Mesh(new THREE.BoxGeometry(122, 80, 2), material);
			wall4.position.set(0, 40, 50);
			//wall.add (wall4);
			let wall5 = new THREE.Mesh(new THREE.BoxGeometry(122, 102, 2), material);
			wall5.position.set(0, 0, 0);
			wall5.rotation.x = Math.PI / 2;
			wall.add(wall5);

			return wall;
		}

		function buildDesk() {
			var geometry = new THREE.BoxGeometry(60, 40, 2);
			var material = new THREE.MeshPhongMaterial({ color: "brown" });
			let desk = new THREE.Mesh(geometry, material);
			desk.name = "desk";
			desk.rotation.x = Math.PI / 2;
			desk.position.set(-29, 25, -29);

			return desk;
		}

		function buildLight() {
			let dirLight = new THREE.DirectionalLight(0xffffff, 1);
			dirLight.color.setHSL(0.1, 1, 0.95);
			dirLight.position.set(- 1, 1.75, 1);
			dirLight.position.multiplyScalar(30);
			return dirLight;
		}

		function buildTryit() {
			let geometry = new THREE.Geometry();
			let sqHeight = Math.sqrt(1.875);
			geometry.vertices.push(new THREE.Vector3(-1.75, 0, 1.75));	// 0
			geometry.vertices.push(new THREE.Vector3(1.75, 0, 1.75)); // 1
			geometry.vertices.push(new THREE.Vector3(1.75, 7.5, 1.75)); // 2
			geometry.vertices.push(new THREE.Vector3(1.75, 7.5 + sqHeight, 0)); // 3
			geometry.vertices.push(new THREE.Vector3(-1.75, 7.5 + sqHeight, 0)); // 4
			geometry.vertices.push(new THREE.Vector3(-1.75, 7.5, 1.75)); // 5
			geometry.vertices.push(new THREE.Vector3(1.75, 0, -1.75)); // 6
			geometry.vertices.push(new THREE.Vector3(-1.75, 0, -1.75)); // 7
			geometry.vertices.push(new THREE.Vector3(-1.75, 7.5, -1.75)); // 8
			geometry.vertices.push(new THREE.Vector3(1.75, 7.5, -1.75)); // 9
			geometry.vertices.push(new THREE.Vector3(1.75, 8.35 + sqHeight, 0)); // 10
			geometry.vertices.push(new THREE.Vector3(-1.75, 8.35 + sqHeight, 0)); // 11
			geometry.vertices.push(new THREE.Vector3(0, 7.5 + sqHeight, 0)); // 12
			geometry.vertices.push(new THREE.Vector3(0, 7.3 + sqHeight, 0)); // 13 (12')

			let face;
			face = new THREE.Face3(0, 1, 2); face.materialIndex = 0;
			geometry.faces.push(face);
			face = new THREE.Face3(0, 2, 5); face.materialIndex = 0;
			geometry.faces.push(face);
			face = new THREE.Face3(5, 2, 3); face.materialIndex = 1;
			geometry.faces.push(face);
			face = new THREE.Face3(5, 3, 4); face.materialIndex = 1;
			geometry.faces.push(face);
			face = new THREE.Face3(9, 8, 4); face.materialIndex = 2;
			geometry.faces.push(face);
			face = new THREE.Face3(9, 4, 3); face.materialIndex = 2;
			geometry.faces.push(face);
			face = new THREE.Face3(6, 7, 8); face.materialIndex = 3;
			geometry.faces.push(face);
			face = new THREE.Face3(6, 8, 9); face.materialIndex = 3;
			geometry.faces.push(face);
			face = new THREE.Face3(1, 6, 9); face.materialIndex = 4;
			geometry.faces.push(face);
			face = new THREE.Face3(1, 9, 2); face.materialIndex = 4;
			geometry.faces.push(face);
			face = new THREE.Face3(7, 0, 5); face.materialIndex = 5;
			geometry.faces.push(face);
			face = new THREE.Face3(7, 5, 8); face.materialIndex = 5;
			geometry.faces.push(face);
			face = new THREE.Face3(4, 3, 10); face.materialIndex = 6;
			geometry.faces.push(face);
			face = new THREE.Face3(4, 10, 11); face.materialIndex = 6;
			geometry.faces.push(face);
			face = new THREE.Face3(3, 4, 11); face.materialIndex = 7;
			geometry.faces.push(face);
			face = new THREE.Face3(3, 11, 10); face.materialIndex = 7;
			geometry.faces.push(face);
			face = new THREE.Face3(2, 9, 13); face.materialIndex = 8;
			geometry.faces.push(face);
			face = new THREE.Face3(2, 13, 3); face.materialIndex = 9;
			geometry.faces.push(face);
			face = new THREE.Face3(9, 3, 13); face.materialIndex = 10;
			geometry.faces.push(face);
			face = new THREE.Face3(8, 5, 13); face.materialIndex = 11;
			geometry.faces.push(face);
			face = new THREE.Face3(8, 13, 4); face.materialIndex = 12;
			geometry.faces.push(face);
			face = new THREE.Face3(5, 4, 13); face.materialIndex = 13;
			geometry.faces.push(face);
			face = new THREE.Face3(1, 0, 7); face.materialIndex = 14;
			geometry.faces.push(face);
			face = new THREE.Face3(1, 7, 6); face.materialIndex = 14;
			geometry.faces.push(face);

			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 0
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 1
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 2
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 3
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 4
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 5
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 6
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 7
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0.5, 1)]); // 8
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(0.5, 1), new THREE.Vector2(0, 1)]); // 9
			geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0.5, 1)]); // 10
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0.5, 1)]); // 11
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(0.5, 1), new THREE.Vector2(0, 1)]); // 12
			geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0.5, 1)]); // 13
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]); // 14
			geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);

			geometry.computeFaceNormals();
			geometry.computeVertexNormals();

			let loader = new THREE.TextureLoader();
			let texture0 = loader.load('https://i.imgur.com/z2MtXiY.jpg');
			let texture1 = loader.load('https://i.imgur.com/uGWeYXj.png');
			let texture2 = loader.load('https://i.imgur.com/H8KaGG9.png');
			let texture3 = loader.load('https://i.imgur.com/z2MtXiY.jpg');
			let texture4 = loader.load('https://i.imgur.com/hbwidJd.jpg');
			let texture5 = loader.load('https://i.imgur.com/fVvpwPI.jpg');
			let texture6 = loader.load('https://i.imgur.com/RGzUo91.png');
			let texture7 = loader.load('https://i.imgur.com/OL8XeeP.png');
			let texture789 = loader.load('https://i.imgur.com/bYqzY3S.png');
			let texture101112 = loader.load('https://i.imgur.com/rggwRSd.png');
			let texture13 = loader.load('https://i.imgur.com/aCIzWuQ.jpg');
			materialArray = [];
			materialArray.push(
				new THREE.MeshLambertMaterial({ map: texture0 }),
				new THREE.MeshLambertMaterial({ map: texture1 }),
				new THREE.MeshLambertMaterial({ map: texture2 }),
				new THREE.MeshLambertMaterial({ map: texture3 }),
				new THREE.MeshLambertMaterial({ map: texture4 }),
				new THREE.MeshLambertMaterial({ map: texture5 }),
				new THREE.MeshLambertMaterial({ map: texture6 }),
				new THREE.MeshLambertMaterial({ map: texture7 }),
				new THREE.MeshLambertMaterial({ map: texture789 }),
				new THREE.MeshLambertMaterial({ map: texture789 }),
				new THREE.MeshLambertMaterial({ map: texture789 }),
				new THREE.MeshLambertMaterial({ map: texture101112 }),
				new THREE.MeshLambertMaterial({ map: texture101112 }),
				new THREE.MeshLambertMaterial({ map: texture101112 }),
				new THREE.MeshLambertMaterial({ map: texture13 }));

			let tryit = new THREE.Mesh(geometry, materialArray);
			tryit.name = "tryit";
			tryit.position.set(-10, 26, -30);
			tryit.rotation.y = -Math.PI / 4;

			return tryit;
		}

		function buildPenBox() {
			let penBox = new THREE.Object3D();
			let loader = new THREE.TextureLoader();
			let texture = loader.load('https://i.imgur.com/8Z4unix.png');
			let material = new THREE.MeshPhongMaterial({
				alphaMap: texture,
				transparent: true,
				alphaTest: 0.1
			});
			let box1 = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 0.1), material);
			box1.position.set(3, 4, 0);
			box1.rotation.y = Math.PI / 2;
			let box2 = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 0.1), material);
			box2.position.set(-3, 4, 0);
			box2.rotation.y = Math.PI / 2;
			let box3 = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 0.1), material);
			box3.position.set(0, 4, 3);
			let box4 = new THREE.Mesh(new THREE.BoxGeometry(6, 8, 0.1), material);
			box4.position.set(0, 4, -3);
			let box5 = new THREE.Mesh(new THREE.BoxGeometry(6, 6, 0.1), material);
			box5.rotation.x = Math.PI / 2;

			penBox.add(box1, box2, box3, box4, box5);
			penBox.traverse(function (obj) {
				obj.castShadow = true;
				obj.receiveShadow = true;
			});
			penBox.rotation.y = -Math.PI / 4;
			penBox.position.set(-30, 26, -40);
			return penBox;
		}

		function judgeFace() {
			subject = sceneColor.getObjectByName("Trump");
			let headCenter = new THREE.Vector3(0, 30, 0);
			subject.localToWorld(headCenter);
			let noseTip = new THREE.Vector3(0, 30, 15);
			subject.localToWorld(noseTip);

			headCenter.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
			material_Moscaic.uniforms.headNDC.value = new THREE.Vector2((headCenter.x + 1) / 2, (headCenter.y + 1) / 2);
			noseTip.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
			if (noseTip.z - headCenter.z > 0) {
				material_Moscaic.uniforms.gran.value = 0.01;
				//console.log('face forward')
			} else {
				material_Moscaic.uniforms.gran.value = 0;
				//console.log('backward');
			}
		}

		function animate() {

			lightAngle += 0.01;
			lightPoster.position.set(50 * Math.cos(lightAngle), 50, 50 * Math.sin(lightAngle));
			shaderMaterialNormal.uniforms.lightpos.value.copy(lightPoster.position);

			requestAnimationFrame(animate);
			if (!finish) {
				console.log("loading...");
				let isOK = true;
				objNameList.forEach(function (name) {
					if (sceneColor.getObjectByName(name) === undefined) {
						isOK = false;
					}
				});
				if (isOK) {
					//loading??
					document.getElementById("loading").style.display = "none";
					$("#info").show();
					finish = !finish;
				}
			} else {
				render();
			}

		}

		function render() {
			judgeFace();

			renderer.setRenderTarget(texSwapRenderTarget);
			renderer.render(sceneTexSwap, cameraTexSwap);
			renderer.setRenderTarget(sobelRenderTarget);
			renderer.render(sceneSobel, cameraSobel);

			// render sceneGrey to renderTarget
			renderer.setRenderTarget(renderTarget);
			renderer.clear();  // clear the buffers of render target
			sceneGrey.traverse(function (obj) {
				if (obj instanceof THREE.Mesh) {
					if (obj.material instanceof Array) {
						obj.material.forEach(function (mat) {
							mat.colorWrite = true;
						});
					} else {
						obj.material.colorWrite = true;
					}
				}
			});

			renderer.render(sceneGrey, camera);

			material_shh.uniforms.imageSize.value = 128;

			// scene1: torusKnot with shaderMaterial (draw eyeNormal)
			renderer.setRenderTarget(renderTargetTeapot);
			renderer.setClearColor(0x000000);
			renderer.render(scene1, camera1);  // produce eyeNormal plot of subject

			// sceneRTT: fullQuad + filter (discard "near black" fragments)
			renderer.setRenderTarget(renderTarget_whole);
			renderer.setClearColor(0xffff00);  // yellow "magic" background ... to be cutout
			renderer.render(sceneRTT, cameraRTT);  // produce outline

			// overlay the lit torusKnot
			renderer.render(sceneRegular, camera1); // camera0: the same as eyeNormal plot

			// switch to screen output
			renderer.setRenderTarget(renderTargetColor);
			renderer.clearColor();  // clear screen buffers
			renderer.render(scene0, camera0);
			renderer.setClearColor(0xffff00);
			planeXX.lookAt(camera.position.x, 25, camera.position.z);

			// set up blockers from sceneGrey (colorWrite is disabled)
			// normalMat.colorWrite = false;
			sceneGrey.traverse(function (obj) {
				if (obj instanceof THREE.Mesh) {
					if (obj.material instanceof Array) {
						obj.material.forEach(function (mat) {
							mat.colorWrite = false;
						});
					} else {
						obj.material.colorWrite = false;
					}
				}
			});
			renderer.render(sceneGrey, camera);

			renderer.render(sceneColor, camera);
			renderer.setRenderTarget(null);
			renderer.render(sceneRed, cameraRed);
			renderer.setRenderTarget(renderTargetColor);
			renderer.clear();
			renderer.setRenderTarget(renderTargetTeapot);
			renderer.clear();
			renderer.setRenderTarget(renderTarget_whole);
			renderer.clear();
		}

	</script>

</body>

</html>